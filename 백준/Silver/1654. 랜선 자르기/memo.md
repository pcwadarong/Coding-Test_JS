# 문제 이해하기

- K개의 랜선이 있다. (길이는 각각 다르다)
- 이 랜선들을 잘라서 N개 이상의 랜선을 만들어야 한다.
- 만들어야 하는 랜선들은 모두 같은 길이여야 한다.
- 만들 수 있는 가장 긴 길이를 찾아야 한다.


# 문제를 푸는 핵심 생각

> "길이를 x로 정했을 때, 랜선을 잘라서 N개 이상 만들 수 있을까?"를 확인하는 문제다.

- 자르는 길이 x가 짧을수록 더 많은 랜선을 만들 수 있다.
- 자르는 길이 x가 길어질수록 만들 수 있는 랜선 수는 줄어든다.

이렇게 결과가 한 방향으로만 변하기 때문에, 이 문제는 이분 탐색으로 풀 수 있다.


# 왜 "최소 랜선"만 보면 안 될까?

- 제일 짧은 랜선(457cm)만 보고 판단하면, 예) 긴 랜선(4000cm)을 제대로 활용하지 못한다.
- 긴 랜선 하나를 여러 개로 자르면 필요한 개수를 쉽게 채울 수 있다.
- 그래서 전체 랜선을 모두 고려해야 한다.


# 이분 탐색으로 푸는 방법

1. `left = 1` (만들 수 있는 최소 길이)
2. `right = 가장 긴 랜선의 길이`
3. `mid = (left + right) / 2`
4. mid 길이로 잘랐을 때 총 몇 개가 나오는지 센다.
5. 만약 N개 이상이면, mid보다 더 긴 길이도 가능할지 확인한다 (`left = mid + 1`).
6. N개 미만이면, 길이를 줄인다 (`right = mid - 1`).
7. 과정 중 가장 길었던 mid를 기억해둔다.


# 이분 탐색 기본 코드

```typescript
let left = 1;
let right = Math.max(...lines);
let answer = 0;

while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const count = lines.reduce((sum, len) => sum + Math.floor(len / mid), 0);

    if (count >= N) {
        answer = mid;
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}

console.log(answer);
```


# 자주 하는 실수들

| 실수 | 이유 |
|:--|:--|
| 최소 랜선 길이로만 판단 | 긴 랜선이 활용되지 않음 |
| 1씩 길이를 올려가며 찾기(a++) | 데이터가 많으면 시간 초과 남 |
| 이분 탐색 방향 헷갈리기 | `count >= N`일 때 left를 올려야 함 |
| mid 계산 실수 | `(left + right) / 2`는 반드시 Math.floor로 정수 처리해야 함 |


# 랜선 문제 풀 때 팁

- 랜선 길이를 정렬할 필요는 없다. 최대값만 뽑으면 된다.
- 길이는 항상 1 이상이므로 `left = 1`부터 시작한다.
- "N개 이상 만들기"가 목표이므로, 개수가 딱 맞을 필요는 없다.
- 나누기할 때 항상 정수 결과를 얻기 위해 Math.floor를 사용한다.


# 요약

1. 랜선 중 최대 길이로 right 설정
2. left = 1로 설정 후 이분 탐색
3. mid 길이로 잘라서 개수 확인
4. 개수 N 이상이면 mid를 키우고, 미만이면 줄인다
5. 그 과정에서 가능한 최대 길이를 저장한다


# 추가로 알아두기

- 랜선 자르기 문제는 나무 자르기(백준 2805) 문제와 풀이 구조가 똑같다.
- 비슷한 문제들:
  - 나무 자르기
  - 랜선 자르기
  - 떡볶이 떡 만들기
  - 배 분배하기

모두 이 패턴을 사용한다.


---

# 단조성(한 방향성) 추가 설명

## 단조성이란?

- 어떤 값을 키우거나 줄일 때, 결과가 한쪽 방향으로만 변하는 성질을 말한다.
- 결과가 오락가락하지 않고 한 방향으로만 가야 한다.
- 단조성이 있으면 이분 탐색이 가능하다.


## 단조성 예시 정리

### 랜선 자르기 문제 (지금 하고 있는 문제)
- 자르는 길이 x를 늘리면 만들 수 있는 랜선 수는 감소한다.
- 자르는 길이 x를 줄이면 만들 수 있는 랜선 수는 증가한다.

단조 감소
이분 탐색 가능


### 나무 자르기 문제 (백준 2805)
- 높은 높이로 자르면 나무를 적게 얻는다.
- 낮은 높이로 자르면 나무를 많이 얻는다.

단조 감소
이분 탐색 가능


### 배열에서 특정 값 이상인 첫 번째 인덱스 찾기
- 정렬된 배열 [1, 3, 5, 7, 9]가 있을 때, 6 이상인 첫 번째 수는 7이다.
- 인덱스를 오른쪽으로 이동할수록 배열 값이 증가한다.

예시 추가: [2, 4, 6, 8, 10]에서 5 이상 찾기 ➔ 6

단조 증가
이분 탐색 가능


### 최소 조건을 만족하는 값 찾기
- 시간 제한 안에 작업을 끝내야 할 때, 속도를 높이면 걸리는 시간이 줄어든다.
- 속도를 낮추면 걸리는 시간이 늘어난다.

단조 감소
이분 탐색 가능

(블루레이 만들기 문제, 코끼리 트럭 문제 등이 여기에 해당한다)


### 게임 레벨업 문제
- 경험치를 올리면 레벨이 증가한다.
- 경험치가 많아질수록 절대 레벨이 줄어들지 않는다.

단조 증가
이분 탐색 가능


---

x를 키우거나 줄일 때 결과가 한 방향으로만 변하는 경우 ➔ 이분 탐색이 가능하다.

랜선 자르기, 나무 자르기, 작업 최소화, 레벨업 등 다양한 문제는 모두 단조성을 이용해서 빠르게 답을 구할 수 있다.

