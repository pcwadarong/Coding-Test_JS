**문제 요약: 해시 함수 구현 문제 (Rabin-Karp 방식의 단순 구현)**

- 문자열을 입력받아, 각 문자를 숫자로 매핑하고, 특정 규칙에 따라 해시값을 계산하는 문제
- 공식: $$\ H = \sum_{i=0}^{l-1} a_i \cdot r^i \mod M \$$
  - $$a_i$$: 각 문자 ('a' = 1, 'b' = 2, ..., 'z' = 26)
  - $$r = 31$$: 해시에서 사용되는 계수 (소수)
  - $$M = 1234567891$$: 모듈러 값 (overflow 방지용 큰 소수)

**50점 코드의 문제점**

```ts
for (let i = 0; i < L; i++) {
  hash = (hash + (charValue) * (r ** i)) % M;
}
```

- `r ** i`는 자바스크립트의 부동소수점 연산으로 인해 정밀도가 깨질 수 있음 (특히 i가 커질수록)
- `r ** i` 자체가 매우 커지기 때문에 `mod M`을 해도 정확도가 보장되지 않음

**100점 코드로 개선한 방식**

```ts
let power = 1;
for (let i = 0; i < L; i++) {
  hash = (hash + (charValue) * power) % M;
  power = (power * r) % M;
}
```

- `power`는 반복문을 돌면서 `r^i` 값을 누적 곱으로 구함
- `mod M`을 매번 적용해 숫자를 작게 유지하고, 정밀도 문제를 피함
- 이 방식은 "modular exponentiation"의 기본 형태로 해시 계산에 안전하고 빠름

**기억할 포인트**

- `power` 변수는 실제로 `r^i`와 같음 (초기값 1에서 시작해 매 루프마다 `power *= r`)
- 자바스크립트의 `charCodeAt(i) - 96`은 알파벳을 1~26으로 변환하는 기본 트릭
- 해시 함수에서 `mod`는 오버플로 방지 + 값 제한 역할
- r, M은 충돌을 줄이고 안정적인 분산을 만들기 위한 상수값으로 소수를 선택함

**요약**: `r ** i` 대신 누적 곱 방식(`power`)을 쓰고 매 연산마다 `% M`을 적용해야 정확하고 안정적인 해시값을 구할 수 있음.

